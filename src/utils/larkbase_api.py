import requests
import pandas as pd
import streamlit as st
import json
from typing import List, Dict, Any

class LarkbaseConfig:
    def __init__(self, app_id=None, app_secret=None, api_endpoint=None):
        self.app_id = app_id or 'cli_a7fab27260385010'
        self.app_secret = app_secret or 'Zg4MVcFfiOu0g09voTcpfd4WGDpA0Ly5'
        self.api_endpoint = api_endpoint or 'https://open.larksuite.com/open-apis'
    
    def to_dict(self):
        return {
            'app_id': self.app_id,
            'app_secret': self.app_secret,
            'api_endpoint': self.api_endpoint
        }

class LarkbaseAuthenticator:
    def __init__(self, config: LarkbaseConfig):
        self.config = config
    
    def authenticate(self):
        url = f"{self.config.api_endpoint}/auth/v3/tenant_access_token/internal"
        response = requests.post(url, json={
            'app_id': self.config.app_id, 
            'app_secret': self.config.app_secret
        })
        response.raise_for_status()
        data = response.json()
        if data.get('code') == 0:
            return data.get('tenant_access_token')
        return None

class LarkbaseDataFetcher:
    def __init__(self, access_token: str, config: LarkbaseConfig):
        self.access_token = access_token
        self.config = config
    
    def fetch_data(self, app_token: str, table_id: str):
        all_records = []
        page_token = None
        has_more = True
        while has_more:
            url = f"{self.config.api_endpoint}/bitable/v1/apps/{app_token}/tables/{table_id}/records"
            headers = {'Authorization': f'Bearer {self.access_token}'}
            params = {
                'page_size': 100,
                'page_token': page_token
            }
            response = requests.get(url, headers=headers, params=params)
            response.raise_for_status()
            response_data = response.json()
            if response_data.get('code') != 0:
                break
            records = response_data.get('data', {}).get('items', [])
            all_records.extend(records)
            has_more = response_data.get('data', {}).get('has_more', False)
            page_token = response_data.get('data', {}).get('page_token')
        return all_records

class LarkbaseDataWriter:
    def __init__(self, access_token: str, config: LarkbaseConfig):
        self.access_token = access_token
        self.config = config
    
    def write_data(self, app_token: str, table_id: str, records: List[Dict[str, Any]], batch_size: int = 100):
        """Ghi d·ªØ li·ªáu v√†o Larkbase theo batch v·ªõi x·ª≠ l√Ω l·ªói chi ti·∫øt.
        
        Args:
            app_token (str): Token c·ªßa ·ª©ng d·ª•ng Larkbase.
            table_id (str): ID c·ªßa b·∫£ng c·∫ßn ghi d·ªØ li·ªáu.
            records (List[Dict[str, Any]]): Danh s√°ch c√°c b·∫£n ghi c·∫ßn ghi.
            batch_size (int, optional): K√≠ch th∆∞·ªõc m·ªói batch. M·∫∑c ƒë·ªãnh l√† 100.
        
        Returns:
            tuple: (success_count, error_count, errors) - S·ªë l∆∞·ª£ng b·∫£n ghi ghi th√†nh c√¥ng, th·∫•t b·∫°i v√† danh s√°ch l·ªói.
        """
        success_count = 0
        error_count = 0
        errors = []  # Kh·ªüi t·∫°o danh s√°ch ƒë·ªÉ l∆∞u tr·ªØ l·ªói
        
        if not records:
            st.warning("‚ö†Ô∏è Kh√¥ng c√≥ b·∫£n ghi n√†o ƒë·ªÉ ghi.")
            return success_count, error_count, errors
        
        # Chia records th√†nh c√°c batch nh·ªè
        total_batches = (len(records) + batch_size - 1) // batch_size
        for i in range(0, len(records), batch_size):
            batch = records[i:i + batch_size]
            batch_number = i // batch_size + 1
            
            try:
                result = self._write_batch(app_token, table_id, batch)
                if result:
                    success_count += len(batch)
                    st.info(f"‚úÖ Batch {batch_number}/{total_batches} ghi th√†nh c√¥ng {len(batch)} b·∫£n ghi.")
                else:
                    error_count += len(batch)
                    error_msg = f"Batch {batch_number}/{total_batches} th·∫•t b·∫°i, kh√¥ng c√≥ th√¥ng tin l·ªói c·ª• th·ªÉ t·ª´ h·ªá th·ªëng."
                    st.error(f"‚ùå {error_msg}")
                    errors.append(error_msg)  # L∆∞u th√¥ng b√°o l·ªói v√†o danh s√°ch
            except Exception as e:
                error_count += len(batch)
                error_msg = f"L·ªói khi ghi batch {batch_number}/{total_batches}: {str(e)}"
                st.error(f"‚ùå {error_msg}")
                errors.append(error_msg)  # L∆∞u th√¥ng b√°o l·ªói v√†o danh s√°ch
                # Ghi log chi ti·∫øt l·ªói n·∫øu c·∫ßn
                st.error(f"Chi ti·∫øt batch l·ªói: {batch[:2]}... (hi·ªÉn th·ªã t·ªëi ƒëa 2 b·∫£n ghi ƒë·∫ßu ti√™n)")
        
        # B√°o c√°o t·ªïng k·∫øt
        st.info(f"üìä T·ªïng k·∫øt: {success_count} b·∫£n ghi th√†nh c√¥ng, {error_count} b·∫£n ghi th·∫•t b·∫°i.")
        return success_count, error_count, errors

    
    def _write_batch(self, app_token: str, table_id: str, records: List[Dict[str, Any]]):
        """Ghi m·ªôt batch records v√†o Larkbase"""
        url = f"{self.config.api_endpoint}/bitable/v1/apps/{app_token}/tables/{table_id}/records/batch_create"
        headers = {
            'Authorization': f'Bearer {self.access_token}',
            'Content-Type': 'application/json'
        }
        
        # Chu·∫©n b·ªã d·ªØ li·ªáu theo format c·ªßa Larkbase
        payload = {
            "records": [{"fields": record} for record in records]
        }
        
        response = requests.post(url, headers=headers, json=payload)
        response.raise_for_status()
        response_data = response.json()
        
        return response_data.get('code') == 0
    
    def update_data(self, app_token: str, table_id: str, record_id: str, fields: Dict[str, Any]):
        """C·∫≠p nh·∫≠t m·ªôt record c·ª• th·ªÉ"""
        url = f"{self.config.api_endpoint}/bitable/v1/apps/{app_token}/tables/{table_id}/records/{record_id}"
        headers = {
            'Authorization': f'Bearer {self.access_token}',
            'Content-Type': 'application/json'
        }
        
        payload = {"fields": fields}
        
        response = requests.put(url, headers=headers, json=payload)
        response.raise_for_status()
        response_data = response.json()
        
        return response_data.get('code') == 0
    
    def delete_data(self, app_token: str, table_id: str, record_ids: List[str]):
        """X√≥a nhi·ªÅu records"""
        url = f"{self.config.api_endpoint}/bitable/v1/apps/{app_token}/tables/{table_id}/records/batch_delete"
        headers = {
            'Authorization': f'Bearer {self.access_token}',
            'Content-Type': 'application/json'
        }
        
        payload = {"records": record_ids}
        
        response = requests.post(url, headers=headers, json=payload)
        response.raise_for_status()
        response_data = response.json()
        
        return response_data.get('code') == 0

def fetch_larkbase_data(app_token, table_id, step_name):
    """H√†m l·∫•y d·ªØ li·ªáu t·ª´ Larkbase, KH√îNG th√™m _record_id v√†o DataFrame"""
    try:
        config = LarkbaseConfig()
        authenticator = LarkbaseAuthenticator(config)
        token = authenticator.authenticate()
        
        if not token:
            st.error("‚ùå Kh√¥ng th·ªÉ x√°c th·ª±c v·ªõi Larkbase")
            return None
        
        fetcher = LarkbaseDataFetcher(token, config)
        records = fetcher.fetch_data(app_token, table_id)
        
        if not records:
            st.warning("‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu")
            return None
        
        # Ch·ªâ l·∫•y fields, KH√îNG th√™m record_id
        data = [record.get('fields', {}).copy() for record in records]
        df = pd.DataFrame(data)
        
        st.success(f"‚úÖ ƒê√£ ƒë·ªçc {len(df):,} b·∫£n ghi t·ª´ {step_name}")
        return df
        
    except Exception as e:
        st.error(f"‚ùå L·ªói khi ƒë·ªçc {step_name}: {str(e)}")
        return None

def clear_and_overwrite_table(app_token, table_id, new_data, step_name):
    """
    X√≥a t·∫•t c·∫£ d·ªØ li·ªáu trong table v√† ghi ƒë√® b·∫±ng d·ªØ li·ªáu m·ªõi
    
    Args:
        app_token (str): Token c·ªßa app
        table_id (str): ID c·ªßa table
        new_data (pd.DataFrame): D·ªØ li·ªáu m·ªõi ƒë·ªÉ ghi ƒë√®
        step_name (str): T√™n b∆∞·ªõc ƒë·ªÉ hi·ªÉn th·ªã log
        
    Returns:
        dict: {"success": bool, "message": str}
    """

    try:
        config = LarkbaseConfig()
        authenticator = LarkbaseAuthenticator(config)
        token = authenticator.authenticate()
        if not token:
            return {"success": False, "message": "Kh√¥ng th·ªÉ x√°c th·ª±c v·ªõi Larkbase"}

        # B∆∞·ªõc 1: L·∫•y t·∫•t c·∫£ record_ids hi·ªán c√≥
        fetcher = LarkbaseDataFetcher(token, config)
        existing_records = fetcher.fetch_data(app_token, table_id)
        if existing_records:
            record_ids = [record.get('record_id') for record in existing_records if record.get('record_id')]
            if record_ids:
                # B∆∞·ªõc 2: X√≥a t·∫•t c·∫£ records theo batch
                writer = LarkbaseDataWriter(token, config)
                batch_size = 100
                for i in range(0, len(record_ids), batch_size):
                    batch_ids = record_ids[i:i + batch_size]
                    success = writer.delete_data(app_token, table_id, batch_ids)
                    if not success:
                        return {"success": False, "message": f"L·ªói khi x√≥a batch {i//batch_size + 1}"}
                
                st.info(f"üóëÔ∏è ƒê√£ x√≥a {len(record_ids)} records c≈© t·ª´ {step_name}")

        # B∆∞·ªõc 3: Ghi d·ªØ li·ªáu m·ªõi
        if isinstance(new_data, pd.DataFrame):
            # Lo·∫°i b·ªè c·ªôt _record_id n·∫øu c√≥
            data_to_write = new_data.copy()
            if '_record_id' in data_to_write.columns:
                data_to_write = data_to_write.drop(columns=['_record_id'])
            
            records = data_to_write.to_dict('records')
        else:
            records = new_data
        
        # Lo·∫°i b·ªè c√°c gi√° tr·ªã NaN/None
        cleaned_records = []
        for record in records:
            cleaned_record = {k: v for k, v in record.items() if pd.notna(v) and k != '_record_id'}
            cleaned_records.append(cleaned_record)
        
        if not cleaned_records:
            return {"success": False, "message": "Kh√¥ng c√≥ d·ªØ li·ªáu h·ª£p l·ªá ƒë·ªÉ ghi"}

        # Ghi d·ªØ li·ªáu m·ªõi
        writer = LarkbaseDataWriter(token, config)
        success_count, error_count, errors = writer.write_data(app_token, table_id, cleaned_records, 100)

        if error_count == 0:
            message = f"‚úÖ ƒê√£ ghi ƒë√® th√†nh c√¥ng {success_count:,} b·∫£n ghi v√†o {step_name}"
            st.success(message)
            return {"success": True, "message": message}
        else:
            message = f"‚ö†Ô∏è Ghi ƒë√® {step_name}: {success_count:,} th√†nh c√¥ng, {error_count:,} l·ªói"
            st.warning(message)
            return {"success": success_count > 0, "message": message}
        
    except Exception as e:
        error_msg = f"‚ùå L·ªói khi ghi ƒë√® {step_name}: {str(e)}"
        st.error(error_msg)
        return {"success": False, "message": error_msg}
